# OOAD

- 대부분의 프론트 === 대화형 : 특정 이벤트에 반응하는 프로그램 방식
- 전체적인 흐름제어 X . 흐름에 맞춰 프로그램 반응 설계
- 이벤트 프로그램, 다이알로그 프로그램  
  : 로직 단편화돼 있음, 일관성 유지하기 위한 스킬 필요(프레임워크(ex. redux)지원되기도 함)

```
**오늘의 목표**   
- 난감한 도메인을 만났을 때 우리는 어떻게 데이터 분석해서 처리할 수 있는가  
- 또한, 데이터 분석의 결과가 객체지향이 될 수 있게!
```

### 객체지향을 위해 알아야 할 것 
- 객체지향은 추상화라는 영역에 포함  
- 객체지향 분석에서는 사물을 있는 그대로 객체로 받아들이는 것이 아니라, 추상화를 이해하고 추상화 기법을 사용하여 모델링함

#### 추상화
1. categorization : 일정 기준에 의해 분류
2. modeling : 특정 특징들을 포함해 모델링(기억해야 할 특징이 무엇인가!)
3. grouping(집합) : 가장 기초적인 추상화. categorization와 다른 이유는, 기준이 무작위적인 점  

#### 그렇다면, 무엇을 기준으로 객체지향 프로그래밍이라고 부르고, 어떤 걸 객체지향 시스템이라고 부르냐
(객체지향 언어의 필수요소)
1. 대체 가능성  
    - 보다 구상형은 추상형으로 대체할 수 있다  
      (=== 자식이 부모 대체할 수 있다, 구상클래스가 인터페이스/추상클래스 대체 가능하다)
    - 나를 보다 큰 카테고리/모델링으로 변형해도 내가 그 자리에 대체할 수 있어!  
    - 상속, 위임 등을 가능하게 만드는 개념
2. 내적 동질성(일관성)
    - 처음 만들었을 때의 원형이 무엇인가! 
    - overwrite된 속성은 만들어진 구상객체을 사용한다

#### 객체 지향에서 객체를 여러개 만들 때, 객체 간 지켜야 할 규칙
(객체지향 언어의 선택요소)
1. 은닉(hiding)
    - 숨기는 것 / 어디까지 보이고, 숨길 것인가
    - 이상적 : 아무것도 안 보여주는 것
2. 캡슐화
    - 은닉과는 상관 없음
    - 캡슐화의 목적은 외부에 정보를 노출하지 않는 것. 
    - 상대방이 몰라도 되는 이상, 알려주지 않고 추상화된 행위만 알려줌. 가장 모르는 수준까지 알려줌


## Tetris
- 실시간으로 일어나는 일을 자동으로 처리함 > 시간이라는 flow에 맞춰 통제  

**필요할 법한 객체 후보**
```
Game : 게임 본체
 | 
 |   |-> Stage : 현재 스테이지 정보
 |-- |-> Score : 점수 및 계산법
 |   |-> Block : 범용 블록 정보
 |
 |-> Panel : 범용 패널  
 |      |- Start : 시작화면
 |      |- Stage End : 스테이지 종료
 |      |- Dead : 죽음
 |      |- Clear : 클리어
 |      |- Report : 결과 화면
 |
 |-> Data : 게임↔렌더링 간 프로토콜
        ↑
        |- Renderer : 범용 렌더링 처리기
```
- 본인의 고유한계와 책임 역할이 있을 것 (**역할, 책임, 권한**이 동시에 부여됨)
- 단방향 의존성(simplex, 단방향 참조)이 이상적!   
  양방향 의존성(multiplex, 양방향 참조)일 경우, 객체지향 무너짐


### Stage : 현재 스테이지 정보

utils

```js
const prop = (target, v) => Object.assign(target,v);

const Stage = class {
  constructor(last, min, max, listener) { // 마지막 판, 최소 속도, 최대 속도, 자신의 변화를 통보받음
    prop(this, {last,min,max,listener});
  }

  clear() { // 상태 초기화
    this.curr = 0;
    this.next(); // 초기화 시작
  }

  next() {
    if (this.curr++ < Stage.last) { // this.curr 증가
      const rate = (this.curr - 1) / (this.last -1);
      this.speed = this.min + (this.max - this.min) + (1-rate);
      this.listener(); // this.curr 올라간 것 외부에 통보
    }
  }
}
```