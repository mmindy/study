# 3. 요구 사항 변경

### 고객이 원하는 것을 알았다고 생각하죠?
너무 이릅니다. 고객은 자신이 실제 원했던 것이 처음 자신들이 얘기했떤 것과 다르다고 판단할 수 있으며, 여러분의 프로그램을 맘에 들어하지만 충분히 좋은 것이 아님을 판단하기도 합니다.
**요구 사항은 항상 변하고, 이 변화에 대처해 고객을 만족시키는 것은 여러분에게 달려 있습니다**

## 요구 사항 변경

>**토드와 지나의 강아지문 버전2.0 - 강아지문이 현재 하는 일**
>1. 피도가 밖에 나가고 싶어 짖어댑니다
>2. 토드 또는 지나가 피도가 짖는 것을 듣습니다
>3. 토드 또는 지나가 리모콘의 버튼을 누릅니다
>4. 강아지 문이 열립니다
>5. 피도가 밖에 나갑니다
>6. 피도는 밖에서 쉬합니다
>	6.1. 문이 자동으로 닫힙니다
>	6.2. 피도가 들어오려고 짖습니다
>	6.3. 토드나 지나가 피도가 짖는 것을 듣습니다(다시)
>	6.4. 토드나 지나가 리모콘을 누릅니다
>	6.5. 강아지 문이 열립니다(다시)
>7. 피도가 안으로 들어옵니다

**현재 강아지문에 대한 의견**
- 토드와 지나는 항상 피도가 짖는 것에 귀 기울여야 하는 점에 지침
- 피도가 짖을 때마다 리모콘을  찾아야 하는 불편함
\>> 피도가 짖으면 문이 자동으로 열리게 하자!

## 고객은 옳습니다 - 다시 그림판으로
- 고객의 요구에 따라 강아지 문을 다시 변경해야 합니다. 피도가 짖을 때마다 문을 열 방법을 찾아야 합니다.
- 요구 사항이 변할 때에도, 여러분은 프로그램을 업데이트하여 고객의 기대에 맞춰 동작하게 만들 준비가 되어 있어야 합니다. **고객의 요구 사항들(기대)에 맞추어 프로그램을 수정하는 것은 여러분의 몫입니다**

## 소프트웨어 분석과 설계에서 변하지 않는 한 가지
- 여러분이 아무리 프로그램을 잘 설계해도, 프로그램은 끊임없이 항상 성장하고 변화합니다
- **요구 사항은 항상 변합니다.** 하지만 유스케이스들이 잘 만들어져 있으면 새로운 요구사항에 맞춰 소프트웨어를 빠르게 바꿀 수 있습니다

## 대체 경로 추가 - 토드와 지나의 강아지 문에 강아지 소리 인식 기능을 추가하세요

>**토드와 지나의 강아지문 ★버전2.1★ - 강아지 문이 하는 일**
>1. 피도가 밖에 나가고 싶어 짖어댑니다
>2. 토드 또는 지나가 피도가 짖는 것을 듣습니다
>	**2.1. 강아지 소리 인식기가 강아지 소리를 '듣습니다'**
>3. 토드 또는 지나가 리모콘의 버튼을 누릅니다
>	**3.1. 강아지 소리 인식기가 강아지 문이 열리도록 신호를 보냅니다**
>4. 강아지 문이 열립니다
>5. 피도가 밖에 나갑니다
>6. 피도는 밖에서 쉬합니다
>	6.1. 문이 자동으로 닫힙니다
>	6.2. 피도가 들어오려고 짖습니다
>	6.3. 토드나 지나가 피도가 짖는 것을 듣습니다(다시)
>		**6.3.1. 강아지 소리 인식기가 강아지 소리를 듣습니다(다시)**
>	6.4. 토드나 지나가 리모콘을 누릅니다
>		**6.4.1. 강아지 소리 인식기가 강아지 문이 열리도록 신호를 보냅니다**
>	6.5. 강아지 문이 열립니다(다시)
>7. 피도가 안으로 들어옵니다

- 새로 추가된 항목은 하위 단계로 추가된 것이 아닌, 유스케이스에서 완전히 다른 경로를 의미합니다

## 여러분이 쓰고 싶은 방식대로 작성하세요 - 유스케이스는 여러분이 이해하기 쉬워야 합니다
- 유스케이스를 작성하는 방식은 다양하지만, 중요한 것은 유스케이스를 보는 사람이 이해하기 쉬워야 한다는 것입니다

>**토드와 지나의 강아지문 ★버전2.2★ - 강아지 문이 하는 일**
>**주 경로**
>1. 피도가 밖에 나가고 싶어 짖어댑니다
>2. 토드 또는 지나는 피도가 짖는 것을 듣습니다
>3. 토드나 지나가 리모콘의 버튼을 누릅니다
>4. 강아지 문이 열립니다
>5. 피도가 나갑니다
>6. 피도가 쉬합니다
>	6.1. 강아지 문이 자동으로 닫힙니다
>	6.2. 피도가 안으로 들여보내 달라고 짖습니다
>	6.3. 토드나 지나가 피도가 짖는 것을 듣습니다(다시)
>	6.4. 토드와 지나가 리모콘의 버튼을 누릅니다
>	6.5. 강아지 문이 열립니다(다시)
>7. 피도가 안으로 들어갑니다
>8. 문이 자동으로 닫힙니다
>
>**대체 경로**
>2.1. 강아지 소리 인식기가 강아지 소리를 듣습니다
>3.1. 강아지 소리 인식기가 강아지 문이 열리도록 신호를 보냅니다
>6.3.1. 강아지 소리 인식기가 강아지 소리를 듣습니다(다시)
>6.4.1. 강아지 소리 인식기가 강아지 문이 열리도록 신호를 보냅니다

- **주 경로** 에 포함된 대체 경로는 선택적인 것이지만, 주 경로를 대체하는 것은 아닙니다
- **대체 경로** 로 빠진 단계는 주 경로를 대체할 수 있는 것으로, 둘 중 하나의 단계만 거칠 수 있습니다


### 원하는 경로를 주 경로로 바꿀 수 있을까요?
- 유스케이스를 원하는 대로 작성할 수 있다면, 원하는 경로를 주 경로로 옮길 수 있겠죠!
- 토드와 지나는 그들이 리모콘을 사용하기보다 강아지 소리 인식기가 피도에게 문을 열어주기를 바랍니다

>**토드와 지나의 강아지문 ★버전2.3★ - 강아지 문이 하는 일**
>**주 경로**
>1. 피도가 밖에 나가고 싶어 짖어댑니다
>2. **강아지 소리 인식기가 강아지 소리를 듣습니다**
>3. **강아지 소리 인식기가 강아지 문이 열리도록 신호를 보냅니다**
>4. 강아지 문이 열립니다
>5. 피도가 나갑니다
>6. 피도가 쉬합니다
>	6.1. 강아지 문이 자동으로 닫힙니다
>	6.2. 피도가 안으로 들여보내 달라고 짖습니다
>	6.3. **강아지 소리 인식기가 강아지 소리를 듣습니다(다시)**
>	6.4. **강아지 소리 인식기가 강아지 문이 열리도록 신호를 보냅니다**
>	6.5. 강아지 문이 열립니다(다시)
>7. 피도가 안으로 들어갑니다
>8. 문이 자동으로 닫힙니다
>
>**대체 경로**
>2.1. 토드 또는 지나는 피도가 짖는 것을 듣습니다
>3.1. 토드나 지나가 리모콘의 버튼을 누릅니다
>6.3.1. 토드나 지나가 피도가 짖는 것을 듣습니다(다시)
>6.4.1. 토드와 지나가 리모콘의 버튼을 누릅니다

- 이제 강아지 소리 인식기와 관련된 단계뜰이 주 경로로 옮겨졌습니다
- 토드와 지나는 대부분의 경우 리모콘을 사용하지 않을 것이기 때문에, 리모콘 관견 단계는 대체 경로에 있는 것이 낫습니다

## 목표에 도달하기 - 시작부터 끝: 하나의 시나리오
- 하나의 목표에 도달하는 데에는 다양한 경로가 있습니다
- 하나의 유스케이스에서도 여러 개의 시나리오가 가능합니다. 시나리오란, 주 경로와 대체 경로 사이에서 만들어 낼 수 있는 특정 경로
- 단, 해당 유스케이스는 시작 조건에 의해 시작되고, 종료 조건에 의해 종료됩니다


#### 첫 단계부터 마지막 단계까지 유스케이스를 거치는 하나의 전체 경로를 "시나리오"라고 부릅니다
#### 대부분의 유스케이스는 몇개의 다른 시나리오가 있지만, 각 시나리오는 항상 같은 사용자 목표를 공유합니다

## 바보같은 질문이란 없습니다
**Q. 유스케이스의 주 경로는 알겠는데, 대체 경로가 뭔지 다시 설명해 줄 수 있나요?**
- A. **대체 경로는 유스케이스에 있는 단계 중에서 선택적이거나, 대체할 방법을 나타내는 단계들입니다.** 대체 경로는 주 경로에 추가되는 추가 단계일 수도 있고, 주 경로와 완전히 다른 경로를 통해 목적을 달성하도록 하는 단계들일 수 있습니다

**Q. 그래서 피도가 밖에서 못 들어오고 있을 때, 그것은 대체 경로의 일부가 맞나요?**
- A. 맞습니다. 유스케이스의 단계 6.1.~6.5.는 대체 경로로, 시스템이 거칠 수 있는 추가 단계입니다. 이는 필수 단계가 아니므로 시스템은 단계 6에서 7로 직접 넘어갈 수 있습니다.

**Q. 6.1과 6.2처럼 그런 것에 대해서는 부(sub)단계를 사용하나요?**
- A. 맞습니다. 추가 단계가 있는 대체 경로는 유스케이스의 주 경로에서 어느 한 단계의 부분으로 일어나는 단계들이기 때문입니다.

**Q. 유스케이스의 부분을 거치는 두 개의 다른 경로가 있을 때, 그것을 무엇이라고 부르나요?**
- A. 그것은 사실 또 다른 종류의 대체 경로일 뿐입니다.
	피도가 짖을 때 토드와 지나가 듣고 열어주는 경로가 있고, 강아지 소리 인식기가 듣고 열어주는 또 다른 경로가 있습니다. **하지만 시스템은 한 번에 둘 중 하나를 위해 설계되었습니다. 동시에 두 개 모두가 아니구요**

**Q. 같은 유스케이스에 하나 이상의 대체 경로가 있어도 되나요?**
- A. 물론이죠. 추가단계를 제공하는 대체 경로가 여러 개 있을 수 있고, 시작에서 끝까지 여러 경로가 있을 수도 있습니다. 심지어 유스케이스를 일찍 끝내는 대체 경록 있을 수도 있습니다.

## 대체 경로는 선택 사항입니다
- 대체 경로는 유스케이스에서 사용하지 않고 건너뛸 수 있다
- 해당 대체 경로가 다루는 내용이 발생하지 않았을 경우, 해당 대체 경로는 유스케이스에 전혀 관여하지 않는다
- 그러나 대체 경로는 항상 사용되지는 않지만, 가끔은 반드시 필요하다. 이는 모든 경로가 같은 목표를 공유하기 때문!
- 대체 경로 없이는 유스케이스가 완벽해질 수 없다


## 요구사항 리스트 변경하기
- 좋은 유스케이스를 만드는 이유는 좋은 요구 사항을 얻기 위해서라는 것을 기억하세요
- 몇 개의 추가 요구사항을 요구사항 리스트에 넣어, 두개의 새로운 대체 경로를 해결해야 합니다

>**토드와 지나의 강아지문 ★버전2.3★ - 강아지 문이 하는 일**
>**주 경로**
>1. ~~피도가 밖에 나가고 싶어 짖어댑니다~~
>2. **강아지 소리 인식기가 강아지 소리를 듣습니다**
>3. **강아지 소리 인식기가 강아지 문이 열리도록 신호를 보냅니다**
>4. ~~강아지 문이 열립니다~~
>5. ~~피도가 나갑니다~~
>6. ~~피도가 쉬합니다~~
>	6.1. ~~강아지 문이 자동으로 닫힙니다~~
>	6.2. ~~피도가 안으로 들여보내 달라고 짖습니다~~
>	6.3. **강아지 소리 인식기가 강아지 소리를 듣습니다(다시)**
>	6.4. **강아지 소리 인식기가 강아지 문이 열리도록 신호를 보냅니다**
>	6.5. ~~강아지 문이 열립니다(다시)~~
>7. ~~피도가 안으로 들어갑니다~~
>8. ~~문이 자동으로 닫힙니다~~
>
>**대체 경로**
>2.1. ~~토드 또는 지나는 피도가 짖는 것을 듣습니다~~
>3.1. ~~토드나 지나가 리모콘의 버튼을 누릅니다~~
>6.3.1. ~~토드나 지나가 피도가 짖는 것을 듣습니다(다시)~~
>6.4.1. ~~토드와 지나가 리모콘의 버튼을 누릅니다~~

>**토드와 지나의 강아지 문 버전2.3 - 요구 사항 리스트**
>1. 강아지 문은 열렸을 때 35cm 이상이어야 한다
>2. 리모콘에 있는 하나의 버튼은 문이 닫혔을 때 누르면 열리고, 열렸을 때 누르면 닫힌다
>3. 강아지 문이 한번 열린 후, 닫지 않으면 자동으로 닫혀야 한다
>4. **강아지 소리 인식기가 강아지가 짖을 때 소리를 구별할 수 있다**
>5. **강아지가 짖을 때 강아지 소리 인식기를 통해 듣고, 강아지 문이 열린다**

- 추가된 요구사항 : 강아지 소리를 "듣는" 것과 강아지 문을 여는 것
- 취소선 표시된 경로는 앞에서 해결한 부분

## 요구사항 변경 - 이제 강아지 문을 다시 작성할 수 있습니다
- 새로운 요구 사항이 생기면 새로운 코드가 필요합니다
- 강아지 소리와 그 소리를 듣고 강아지 문을 열어 줄 강아지 소리 인식기가 필요합니다

※ 추가사항
- `DogDoorSimulator` : 피도가 짖는 것 시뮬레이션.
	피도는 시스템의 외부에 있어서 그를 위한 객체는 필요 없다는 것을 기억하세요
- `recognize()` : 강아지 소리를 들을 때 마다 호출되는 메소드
- `BarkRecognizer` : 강아지 소리 인식기에 대한 코드
- `DogDoor` : 해당 클래스 내 `open()`이 있어, 따로 수정할 부분 없음

## 강아지 소리 인식하기 - "멍멍"이었나요 내가 들은 게?
```js
class BarkRecognizer {
	constructor(door){
		this._door = door;
	}

	recognize(bark) {
		console.log("BarkRecognizer : Heard a '"+bark"'");
		this._door.open();
	}
}
```

## 바보같은 질문이란 없습니다
**Q. 이게 다예요? `BarkRecognizer` 클래스가 하는 일이 별로 없는 거 같은데요**
- A. 지금은 그래요. 요구 사항이 간단하기에 여러분의 코드도 매우 간단합니다
	하드웨어가 강아지 소리를 들을 때마다, `BarkRecognizer` 클래스의 `recognize()`를 호출하고 강아지 문을 엽니다. **"가능한 간단하게 하라"** 를 기억하세요

**Q. 하지만 피도 외의 강아지가 짖으면 어떡하죠? `BarkRecognizer`가 문을 열기 전에 피도가 짖는 게 맞는지 확인해야 하지 않나요?**
- A. `BarkRecognizer`가 모든 강아지 소리를 듣지만 모든 강아지에게 문을 열어주기를 바라는 것은 아니죠? 이것은 나중에 고치도록 하지요. 테스트할 때 이것에 대해 좀더 생각해야 할 거예요

## 테스트 구동

```js
class DogDoor {
	constructor() {
		this._open = false;
	}

	open() {
		console.log("The dog door opens.");
		this._open = true;
	}

	close() {
		console.log("The dog door closes.");
		this._open = false;
	}

	isOpen() {
		return this._open;
	}
}

class Remote {
	constructor(door) {
		this._door = door;
	}

	pressButton() {
		console.log("Please this remote control button.");
		if (this._door.isOpen()) {
			this._door.close();
		} else {
			this._door.open();
			setTimeout(function() {
				console.log("set time out");
				this._door.close();
				clearTimeout();
			}, 5000);
		}
	}
}

class BarkRecognizer {
	constructor(door){
		this._door = door;
	}

	recognize(bark) {
		console.log("BarkRecognizer : Heard a '"+bark+"'");
		this._door.open();
	}
}
```

```js
const door = new DogDoor();
const recognizer = new BarkRecognizer(door);
const remote = new Remote(door);

console.log("Fido barks to go outside.");
recognizer.recognize("woof");

console.log("Fido has gone outside.");
console.log("Fido's all done.");

try {
	// Thread.currentTread().sleep(1000);
} catch (
	// InterruptedException e
){ }

console.log("..but he's stuck outside!");
console.log("Fido starts barking.");
recognizer.recognize("woof");
console.log("Fido's back inside.");
```

**우리 강아지 문의 새 버전에서, 강아지 문이 자동으로 닫히지 않습니다!**
`Remote`클래스의 `pressButton()`에는 5초 후 자동 닫힘 기능이 있지만, `BarkRecognizer` 클래스에는 해당 기능이 없습니다.(열리고 끝)
-> 이를 해결하려면, `BarkRecognizer`에 기존처럼 타이머 기능을 추가하면 되지!
-> 그러나, `Remote`와 중복코드 발생! **중복코드는 좋은 아이디어가 아닙니다. 하지만 강아지 문을 닫는 코드는 어디에 있어야 하죠?**

**항상 강아지 문이 자동으로 닫히게 합시다**
지나는 강아지 문이 열린 상태로 있는 것을 바라지 않으니, 강아지 문은 항상 자동으로 닫혀야 합니다.
문을 자동으로 닫는 코드는 `DogDoor` 클래스로 옮길 수 있습니다.

## 강아지 문 업데이트하기

```js
class DogDoor {
	constructor() {
		this._open = false;
	}

	open() {
		console.log("The dog door opens.");
		this._open = true;

		setTimeout(function() {
			console.log("set time out");
			this._door.close();
			clearTimeout();
		}, 5000);
	}

	close() {
		console.log("The dog door closes.");
		this._open = false;
	}

	isOpen() {
		return this._open;
	}
}

class Remote {
	constructor(door) {
		this._door = door;
	}

	pressButton() {
		console.log("Please this remote control button.");
		if (this._door.isOpen()) {
			this._door.close();
		} else {
			this._door.open();
		}
	}
}

class BarkRecognizer {
	constructor(door){
		this._door = door;
	}

	recognize(bark) {
		console.log("BarkRecognizer : Heard a '"+bark+"'");
		this._door.open();
	}
}
```

#### 가끔은 요구 사항을 변경하는 중에 여러분이 알지 못했던 기존의 문제를 발견하게 되기도 합니다
#### 변경은 지속적으로 일어나고, 여러분의 시스템은 여러분이 변경할 때마다 항상 개선되어야 합니다


## OOA&D 도구상자

### 요구사항
- 좋은 요구 사항은 시스템이 고객이 기대한 대로 동작하도록 합니다
- 여러분의 요구 사항이 시스템의 유스케이스의 모든 단계들을 담고 있는지 확인하세요
- 유스케이스를 사용해서 고객이 잊고 얘기하지 않았던 것들을 찾아내세요
- 유스케이스는 시스템에 추가되어야 할 불완전하거나 빠진 요구사항들을 분명하게 합니다
- 요구 사항은 항상 끊임없이 변화합니다(그리고 성장합니다)

### 객체지향의 원리
- 변화하는 것을 캡슐화하세요

### 핵심정리
- 요구사항은 프로젝트를 진행하는 내내 계속 바뀝니다
- **요구사항이 변하면 시스템은 그 새로운 요구사항을 해결하기 위해 변경되어야 합니다**
- 시스템이 새롭게 또는 다른 방식으로 동작해야 할 때, 여러분의 유스케이스를 고치는 것부터 시작하세요
- **시나리오** 는 유스케이스를 처음부터 끝까지 진행하는 하나의 경로입니다
- 각 시나리오가 고객을 위해 같은 목표를 가지고 있기만 하면, **하나의 유스케이스에는 여러 개의 시나리오가 있을 수 있습니다**
- **대체 경로** 들은 가끔만 일어나는 단계들일 수 있고, 또는 유스케이스에서 부분적으로 완전히 다른 경로를 제공할 수도 있습니다
- 어떤 단계가 시스템의 동작 방식에서 선택적이거나 또는 시스템을 사용하는 대체 경로를 제공하면, 3.1, 4.1, 그리고 5.1이나 2.1.1, 2.2.1, 그리고 2.3.1처럼 번호로 매겨진 부 단계를 사용하세요
- **거의 대부분 중복 코드는 피해야 합니다.** 중복 코드는 유지보수 할 때의 골칫거리이며, 보통은 시스템의 설계에 문제가 있다는 의미입니다.
