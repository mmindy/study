# 2. 요구사항 수집

### 모두들 고객을 만족시키고 싶어합니다
- 좋은 소프트웨어를 만드는 첫 번째 단계는 **소프트웨어가 고객이 원하는 기능을 수행하도록 하는 것** 입니다.
- **그런데 어떻게 고객이 정말로 원하는 것을 알아내죠??**
	또, 어떻게 고객이 진정 원하는 것을 고객 스스로 알고 있는지 확인하죠??
	\>> 이부분이 바로 **요구사항의 수집이 필요한 부분** 입니다.
- 이 장에서는 고객이 원하는 것을 만들어주어, **고객을 만족시키는 방법** 을 배웁니다.

## 새로운 프로그래밍 일이 생겼습니다 - 덕의 강아지 문
- 버튼 하나로 작동하는 강아지 문
- 첫번째 고객 : 토드와 지나, 강아지 피도

## 강아지 문부터 시작합니다

```js
class DogDoor {
	constructor() {
		this._open = false;
	}

	open() {
		console.log("The dog door opens.");
		this._open = true;
	}

	close() {
		console.log("The dog door closes.");
		this._open = false;
	}

	isOpen() {
		return this._open;
	}
}
```

## 리모컨 작동하기

```js
class Remote {
	constructor(door) {
		this._door = door;
	}

	pressButton() {
		console.log("Please this remote control button.");
		if (this._door.isOpen()) {
			this._door.close();
		} else {
			this._door.open();
		}
	}
}
```

## 테스트 구동
```js
const door = new DogDoor();
const remote = new Remote(door);

console.log("Fido barks to go outside.");
remote.pressButton();
console.log("Fido has gone outside.");
remote.pressButton();
console.log("Fido's all done.");
remote.pressButton();
console.log("Fido's back inside.");
remote.pressButton();
```

## 그런데 지나가 사용해보니,,
- 문이 빨리 닫히지 않음
- 피도 친구들이 들어옴

> **연필을 깎으며 - 현재 강아지 문이 무엇이 문제죠?**
> 피도의 행동에 주인이 모두 반응해주어야 해서, 신경쓸 일이 많음?

**문이 토드와 지나가 원하던 대로 동작하지 않습니다**
- 토드와 지나는 강아지 문을 닫아야 하는 것을 바라지 않았습니다
- 더 안 좋은 것은 문의 사용 방식이 새로운 문제를 일으켰습니다.(토끼와 쥐 출입)

## 이를 해결해 봅시다. 우리의 계획
1. 강아지 문에 대한 요구사항을 수집한다
2. 문이 실제로 무엇을 해야하는지 알아낸다
3. 토드와 지나로부터 추가정보를 얻는다
4. 문을 잘 만든다

## 도대체 하나의 요구사항이라는 것이 정확히 무엇입니까?
**그것은 여러분의 <u>시스템</u>이 <u>올바르게 동작</u>하기 위해서 <u>수행하는</u> <u>특정한 하나의 일</u>입니다**
- **시스템** : 작업 중인 완성된 애플리케이션이나 프로젝트. 여기선 토드와 지나의 완성된 강아지문 만들기
- **올바르게 동작** : 시스템이 올바르게 동작하는지는 고객이 결정함. 만약 요구사항을 빼먹었거나 고객이 잊은 기능을 끌어내어 구현하지 않으면, 시스템은 제대로 동작하지 않는 것
- **수행하는** : 강아지 문 시스템은 여러가지 일을 수행해야 함. 토드와 지나가 제안했던 모든 것이 시스템이 수행할 일들
- **특정한 하나의 일** : 하나의 요구사항은 보통 한 가지 일이고, 이를 해결했다는 것을 확인하기 위해 테스트를 할 수 있음

## 고객에게 귀를 기울이세요
- 요구사항들에 관한 한, 가장 좋은 방법은 **원하는 것을 고객이 직접 말하게 하는 것**
- 이 상황에서는 어떻게 프로그램을 만들지 고민하는 것이 아닌, 시스템이 거짓해야 할 일을 확실히 파악하는 것이 중요!

## 요구사항 리스트 만들기
>**토드와 지나의 강아지문 v.2.0. 요구사항 리스트**
>1. 강아지 문이 열렸을 때 35cm 이상이어야 한다
>2. 리모콘에 있는 하나의 버튼은 문이 닫혔을 때 누르며 열리고, 열렸을 때 누르면 닫힌다.
>3. 강아지 문이 한번 열린 후, 닫지 않으면 자동으로 닫혀야 한다.
><-- 여분의 공간을 남겨서 추가 요구 사항을 적는다 -->


**여러분은 강아지 문이 어떻게 사용될지를 이해해야 합니다.**
- 가끔은 고객조차도 자기들이 원하는 것을 모르기 때문에,
	여러분은 시스템이 해야할 일을 정하기 전에, 고객에게 여러가지 질문을 하여 고객들이 원하는 것을 알아내야 합니다.
- **여러분은 고객이 요구한 것 이상을 생각할 수 있게 되고, 고객이 자신의 문제점을 깨닫기도 전에 그들이 필요할만한 요구사항을 추측할 수 있습니다**

> **연필을 깎으며 - 토드와 지나가 미처 생각하지 못한 것은 어떤 것이 있을까요?**
> ?ㅇ?

## 강아지 문이 정말 해야 할 일은 무엇일까요? - 토드와 지나가 필요로 하는 것 알아내기
- 프로젝트 중간에 변경사항이 발생하는 것을 최소화하려면 요구 사항의 수집단계에서 고객이 미처 생각하지 못했지만 나중에 발생할 문제들까지 짚고 넘어가야 함

>**토드와 지나의 강아지문 v.2.0. 강아지 문이 하는 일**
>1. 피도가 밖에 나가고 싶어 짖습니다
>2. 토드 또는 지나가 피도가 짖는 소리를 듣습니다
>3. 토드 도는 지나가 리모콘의 버튼을 누릅니다
>4. 강아지 문이 열립니다
>5. 피도가 밖으로 나갑니다
>6. 피도는 밖에서 쉬합니다
>7. 피도가 안으로 들어옵니다
>8. 강아지 문이 자동으로 닫힙니다

## 바보 같은 질문이란 없습니다
**Q. 하나의 요구사항은 고객이 원하는 애플리케이션의 기능들 중에 하나를 말하는 건가요?**
- A. 하나의 요구 사항은 실제로 더 많은 것을 포함하고 있습니다. **고객이 시스템에 원하고 기대하는 것과 꼭 해야 한다고 생각하는 것을 찾는 것부터 시작하기!**
	좋으 요구 사항은 고객이 여러분에게 말하는 것 이상의 것을 포함하고 있으며, 예상 밖의 상황에서도 시스템이 잘 동작하도록 하는 내용도 포함하고 있다.

**Q. 토드와 지나를 위한 시스템은 단지 강아지 문을 말하는 거죠?**
- A. 시스템은 고객의 목적을 맞춰주기 위해 필요한 모든 것이라 할 수 있습니다.
	시스템은 강아지문, 리모콘이 포함되고 토드와 지나,피도는 시스템의 일부는 아니지만 시스템을 설계할 때 고려해야 할 대상입니다.

**Q. 나는 왜 내가 토드와 지나가 강아지문을 어떻게 이용할 지, 그리고 뭐 잘못될 것이 없는 지까지 알아내야 하는지 잘 모르겠습니다. 그건 그들의 문제지 내 문제가 아니잖아요?**
- A. 위대한 소프트웨어를 만드는 데 첫 번재 단계는 고객이 원하는 것을 만들어 줘야 합니다. 그럴려면 위와 같은것들을 잘 알고 있어야 문제를 해결할 수 있습니다.

### 좋은 요구 사항을 얻는 가장 좋은 방법은 시스템이 무엇을 해야 하는지를 이해하는 것입니다

## 문제 발생에 대한 계획안 - 잘못될 수 있는 것은 잘못되기 마련입니다
>1. 피도가 밖에 나가고 싶어 짖습니다 --**피도가 밖에 나가고 싶을 때 표현하는 방식-짖기, 긁기 등**
>2. 토드 또는 지나가 피도가 짖는 소리를 듣습니다 --**토드와 지나가 집에 없거나 듣지 못하면?**
>3. 토드 도는 지나가 리모콘의 버튼을 누릅니다 --**피도가 짖는 의미가 다른 것이면?**
>4. 강아지 문이 열립니다 --**문이 열리다 다른 것에 걸리면? 이건 하드웨어 문제라 빼기**
>5. 피도가 밖으로 나갑니다 --**피도가 안 나가면??**
>6. 피도는 밖에서 쉬합니다
>7. 피도가 안으로 들어옵니다 --**피도가 볼일을 다 안 봤는데 문이 닫히면??**
>8. 강아지 문이 자동으로 닫힙니다 --**문이 먼저 닫혀 피도가 밖에 있으면, 토드와 지나가 밖에서 듣는 걸 듣고 리모콘 동작시킬 수 있을까?**

## 잘못될 상황 예측하기 - 시스템의 문제는 대체 경로가 해결

>**토드와 지나의 강아지문 v.2.0. 강아지 문이 하는 일**
>1. 피도가 밖에 나가고 싶어 짖습니다
>2. 토드 또는 지나가 피도가 짖는 소리를 듣습니다
>3. 토드 도는 지나가 리모콘의 버튼을 누릅니다
>4. 강아지 문이 열립니다
>5. 피도가 밖으로 나갑니다
>6. 피도는 밖에서 쉬합니다
>	**>> 아래와 같은 추가적인 단계 = "대체경로" / 대체경로 통해 생각지 않았던 문제 해결 가능!**
>	i. 문이 자동으로 닫힙니다
>	ii. 피도가 들어오려고 짖습니다
>	iii. 토드나 지나가 피도가 짖는 것을 듣습니다(다시)
>	iv. 토드나 지나가 리모컨을 누릅니다
>	v. 강아지 문이 다시 열립니다(다시)
>7. 피도가 안으로 들어옵니다
>8. 강아지 문이 자동으로 닫힙니다

**예! 여러분은 유스케이스를 쓰고 있습니다**

## 유스케이스를 소개합니다

**유스케이스란?**
- 시스템이 어떤 일을 수행하기 위해 거쳐야 하는 단계
- 새로 만들 시스템이나 소프트웨어 변경 사항에 대한 요구 사항을 찾아내는 방법
- 각 유스케이스는 '특정 목표'를 달성하기 위해 시스템이 사용자 또는 다른 시스템과 어떻게 '상호작용'하는지를 전달하는 하나 이상의 '시나리오'를 제공함
- **유스케이스는 '고객의 목표'가 완수되면 끝나게 됨**

**유스케이스는 <u>고객의</u> <u>특정한 목표</u>를 달성하기 위해 여러분의 시스템이 <u>무엇을 하는지를</u> 기술합니다**
- **고객의** : 사용자는 시스템의 부분이 아니고 시스템의 외부에 있습니다
- **특정한** : 하나의 유스케이스는 하나의 목표에만 집중합니다.
		- 여기서의 목표: 침대에서 나오지 않고 피도를 밖으로 나갈 수 있게 하는 것 (피도의 강아지문 이용빈도 체크 원한다면 그것은 또 다른 유스케이스가 필요한 목표가 됨)
- **목표를** : 고객의 목표가 유스케이스의 핵심!
- **무엇을** : 유스케이스는 '무엇'에 관한 것! ('어떻게'는 나중 일)
- **하는지** : 시스템이 무엇을 '해야' 하는지에 집중!

## 하나의 유스케이스, 세 가지 부분
좋은 유스케이스에는 세 가지 부분이 있고, 유스케이스가 일을 끝내려면 이들 모두가 필요함

### 1. 명확한 가치
유스케이스가 고객의 목표 달성에 도움이 되어야 함

### 2. 시작과 종료
모든 유스케이스는 시작 시점과 종료시점이 있어야 함. 뭔가가 유스케이스를 기동시키고, 유스케이스가 완료되었음을 표시하는 상태가 있어야 함.

### 3. 외부 기동자(액터)
모든 유스케이스는 액터에 의해 시작됨. 액터는 주로 사람이지만, 시스템 외부의 어떤 것이나 될 수 있음!


## 바보 같은 질문이란 없습니다
**Q. 유스케이스는 시스템이 제대로 동작하기 위해 수행해야 할 단계들을 표시한 리스트입니다. 맞나요?**
- A. 대부분의 경우 맞습니다.
	유스케이스의 핵심 중 하나가 유스케이스가 하나의 특정 목표를 달성하는 데 초점을 맞추고 있다는 것을 잊으면 안 됨!

**Q. 유스케이스는 시스템이 목표 달성을 위해 무엇을 해야 하는지에 대한 것입니까?**
- A. 맞습니다. 여러분이 한 가지 일을 위해 시스템이 해야 할 일을 적는다면, 그것이 아마 하나의 유스케이스일 겁니다.

**Q. 하지만 유스케이스가 구체적이지 않아요. 각 유스케이스는 왜 Remote 클래스나 DogDoor클래스에 대해 애기하지 않았죠?**
- A. 유스케이스는 시스템을 독자에게 설명하기위한 것으로, 독자는 프로그래머, 고객(사용자) 등 관련된 모든 사람이다. (모두에게 유용하도록) 일반적으로 단순하고 일상적인 용어를 사용해야 함

**Q. 유스케이스가 유스케이스 다이어그램과 같은 것입니까?**
- A. 아닙니다. 유스케이스들은 일련의 단계들입니다. 유스케이스 다이어그램은 유스케이스들을 시각적으로 보여주는 방법입니다.

**Q. 그러면 유스케이스를 가지고 어떻게 실제 코드를 만들죠?**
- A. 그건 애플리케이션 작성 과정에서 또 다른 단계이며, 유스케이스의 목적이 코드를 어떻게 작성할지를 나타내는 것은 아닙니다.

**Q. 유스케이스가 코드 작성에는 별 도움이 되지 않으면, 유스케이스에 이렇게 시간을 들이는 이유가 뭐죠?**
- A. 유스케이스는 고객이 원하는 소프트웨어를 알아내는 도구이며, 이를 통해 시스템을 구현할 코드 작성 준비가 되 것입니다.

## 유스케이스를 가지고 요구사항 체크하기
- 처음 작성했던 요구 사항 목록과 유스케이스를 비교하여 빠진 게 없는지 확인

>**초기 작성 요구 사항 목록**
>1. 강아지 문은 열렸을 때 35cm 이상
>2. 리모콘에 있는 하나의 버튼은 문이 닫혔을 떄 누르면 열리고, 열렸을때 누르면 닫힌다.
>3. 강아지 문이 한번 열린 후, 닫지 않으면 자동으로 닫혀야 한다.

>**유스케이스**
>1. 피도가 밖에 나가고 싶어 짖습니다  --- N/A
>2. 토드 또는 지나가 피도가 짖는 소리를 듣습니다  --- N/A
>3. 토드 도는 지나가 리모콘의 버튼을 누릅니다  --- 2
>4. 강아지 문이 열립니다  --- 2
>5. 피도가 밖으로 나갑니다  --- 1
>6. 피도는 밖에서 쉬합니다  --- N/A
>	i. 문이 자동으로 닫힙니다  --- 3
>	ii. 피도가 들어오려고 짖습니다  --- N/A
>	iii. 토드나 지나가 피도가 짖는 것을 듣습니다(다시)  --- N/A
>	iv. 토드나 지나가 리모컨을 누릅니다  --- 2
>	v. 강아지 문이 다시 열립니다(다시)  --- 2
>7. 피도가 안으로 들어옵니다  --- 1
>8. 강아지 문이 자동으로 닫힙니다  --- 3
> cf. N/A : Not Applicable. 적용되지 않음

## 이제 우리가 코드를 작성할 수 있을까요?
- 유스케이스와 요구사항 완성 후, 고객이 만족할 만한 코드작성 준비 완료!
- 요구사항을 검토하고 무엇을 코딩할지 파악하자

>**요구 사항 리스트**
>1. 강아지 문은 열렸을 때 35cm 이상 -- 요건 하드웨어 담당자의 일
>2. 리모콘에 있는 하나의 버튼은 문이 닫혔을 떄 누르면 열리고, 열렸을때 누르면 닫힌다. -- 해당 코드는 이미 존재
>3. 강아지 문이 한번 열린 후, 닫지 않으면 자동으로 닫혀야 한다. -- 추가부분!

## 자동으로 문닫기 - 강아지 문에 타이머 추가하기

```js
class DogDoor {
	constructor() {
		this._open = false;
	}

	open() {
		console.log("The dog door opens.");
		this._open = true;
	}

	close() {
		console.log("The dog door closes.");
		this._open = false;
	}

	isOpen() {
		return this._open;
	}
}

class Remote {
	constructor(door) {
		this._door = door;
		this.timer = null;
	}

	pressButton() {
		console.log("Please this remote control button.");
		if (this._door.isOpen()) {
			this._door.close();
		} else {
			this._door.open();
			this.timer = setTimeout(()=>{
				door.close();
				clearTimeout(this.timer);
				this.timer = null;
			}, 5000);
		}
	}
}

const door = new DogDoor();
const remote = new Remote(door);
```

## 해당 코드가 동작한다면, 토드와 지나에게 보여줍시다
### 여러분의 시스템은 실제 상황에서 동작해야 합니다
- 우리는 주 경로 뿐만 아니라 대체 경로도 테스트해야 합니다
- 새로운 문을 보여주기 전에 피도가 볼일을 보고 곧장 안으로 들어오지 않을 경우를 확인해 봅시다

### 그래서 문제가 일어날 경우에 대해 계획하고 테스트하세요
- 대체경로는 시스템을 사용할 때마다 수행되는 것은 아님


###################################### 새로운 시물레이션 위치


## 새로운 강아지 문을 전달하기
**잘 동작하는 애플리케이션, 만족한 고객들**

## 유스케이스 파헤치기 - 행복한 경로(주경로) 알아보기
- 시스템이 잘 수행될 때 무조건 주 경로의 순서로 진행됨.
	(예외 발생 시, 대체 경로로 빠지기 때문에 주 경로와는 멀어지게 됨)
- 주 경로와 대체 경로 모두의 목적은 고객을 목표로 이끌어 만족시키는 것.

## 새로운 용어
- **외부 구동자(액터)** : 유스케이스에 설명된 단계들의 리스트를 시작시킨다. 외부 구동자가 없으면 유스케이스는 시작되지 않는다.
- **유스케이스** : 좋은 요구 사항들을 수집하게 도와준다. 시스템이 할 일에 관한 이야기를 한다.
- **시작 조건** : 유스케이스의 첫 번째 단계
- **요구 사항** : 성공하기 위해 시스템이 해야 할 일
- **명확한 가치** : 명확한 가치는 유스케이스의 목적이며, 이것이 없으면 유스케이스는 누구에게도 유용하지 않으며, 실패한다.
- **종료 조건** : 유스케이스가 언제 끝나는지 알려준다. 마지막 단계
- **주 경로** : 모든 것이 제대로 진행되었을 때 시스템이 하는 일. 고객이 시스템에 대해 이야기할 때 보통 이것을 얘기한다.


## 연필을 깎으며 - 새로운 유스케이스 작성해보기

- **시작 조건** 과 **외부 기동자** 는 보통 유스케이스의 첫번째 단계의 일부입니다.
- **종료 조건** 은 거의 항상 유스케이스의 마지막 단계입니다. 주경로의 마지막 단계가 종료 조건!(대체경로가 있을 경우, 종료 조건은 대개 마지막 문장이 아닙니다.)
- **명확한 가치** 는 목표가 명확히 명시될 겅우 정해집니다.

### 크리스틴과 벳시의 강아지 문
#### 유스케이스
[명확한 가치] [외부 기동자: 크리스틴]
>1. 크리스틴이 코드를 입력한다 [시작 조건]
>2. 강아지 문과 창문이 잠긴다 [종료 조건]

- 명확한 가치: 벳시는 크리스틴이 벳시를 밖에 내보낼 때 외에는 밖으로 나갈 수 없습니다

#### 요구사항 리스트
>1. 키패드는 4자리 코드를 입력받아야 한다
>2. 키패드는 강아지 문을 잠글 수 있어야 한다

### 홀리와 브루스의 강아지 문
#### 유스케이스
[명확한 가치] [외부 기동자: 홀리와 브루스]
>1. 브루스가 발톱으로 문을 긁는다 [시작 조건]
>2. 문이 열린다
>3. *브루스가 밖에 나간다*
>4. *강아지 문이 자동으로 닫힌다*
>5. *브루스는 밖에서 쉬한다*
>6. *브루스가 다시 문을 긁는다*
>7. *강아지 문이 다시 열린다*
>8. *브루스가 집안으로 들어온다*
>9. *문이 자동으로 닫힌다* [종료 조건]

#### 요구사항 리스트
>1. 강아지 문은 강아지가 긁는 것을 감지해야 한다
>2. 강아지 문은 명령(1번에 명시)에 따라 열릴 수 있어야 한다

### 존과 텍스의 강아지 문
#### 유스케이스
[명확한 가치] [외부 기동자: 존]
>1. *(어떤 방법으로든) 강아지 문이 열린다* **>>정보 부족** [시작 조건]
>2. 텍스가 밖에 나간다
>3. 자동으로 문이 닫힌다
>4. *텍스가 밖에서 논다*
>	i. *텍스가 진흙투성이가 된다*  **>> 대체경로: 진흙투성이가 꼭 될 필요는 없으니까**
>	ii. *존이 텍스를 씻긴다*
>5. 존이 버튼을 누른다
>6. 강아지 문이 열린다
>7. *텍스가 안으로 들어온다*
>8. *문이 자동으로 닫힌다* [종료 조건]

## OOA&D 도구 상자를 위한 도구들
### 요구사항들
- 좋은 요구 사항은 시스템이 고객이 기대한 대로 동작하도록 합니다
- 여러분의 요구 사항이 시스템 유스케이스의 모든 단계들을 담고 있는지 확인하세요
- 유스케이스를 사용해서 고객이 잊고 얘기하지 않았던 것들을 찾아내세요
- 유스케이스는 시스템에 추가되어야 할 불완전하거나 빠진 요구 사항들을 분명하게 합니다
**앞으로 객체지향 기본, 객체지향 원리 추가될 예정!**

### 핵심정리
- **요구 사항** 은 시스템이 제대로 동작하기 위해 해야 할 일입니다
- 초기 요구 사항은 보통 고객이 말해줍니다
- 좋은 요구 사항들을 만들려면, 유스케이스를 만들어야 합니다
- **유스케이스** 는 시스템이 해야 할 일을 자세하고 명확하게 설명합니다
- 하나의 유스케이스는 **하나의 목표** 를 가집니다. 하지만 그 목표를 이루는 방법은 여러가지입니다
- 좋은 유스케이스는 **시작 조건, 종료 조건, 외부 구동자(액터), 사용자의 명확한 가치** 를 가지고 있습니다
- 유스케이스는 단지 시스템이 어떻게 동작하는지를 말하는 것입니다
- 여러분의 시스템이 달성해야 할 각 목표에 대해 최소 하나 이상의 유스케이스가 필요합니다
- 유스케이스들을 작성 후, 요구 사항들을 다듬거나 추가할 수 있습니다
- 여러분의 유스케이스 모두를 가능하게 하는 요구 사항 리스트는 좋은 요구 사항 리스트입니다
- 여러분의 시스템은 모든 게 여러분의 기대대로 돌아갈 때 뿐만 아니라, 실제 상황에서도 동작해야 합니다
- 문제가 생기면 시스템은 대체 경로를 사용해서 시스템의 목표를 달성해야 합니다
